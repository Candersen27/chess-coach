<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Coach - Interactive Chessboard</title>

    <!-- chessboard.js CSS -->
    <link rel="stylesheet" href="chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-top: 0;
            text-align: center;
        }

        .main-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .left-column {
            flex: 0 0 550px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-column {
            flex: 1;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chat-column {
            flex: 0 0 350px;
            display: flex;
            flex-direction: column;
        }

        #board {
            width: 500px;
            height: 500px;
            margin: 0 auto;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-wrapper label {
            display: inline-block;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 4px;
            background-color: #2196F3;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-input-wrapper label:hover {
            background-color: #0b7dda;
        }

        .info-panel {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
        }

        .info-label {
            font-weight: bold;
            color: #555;
        }

        .info-value {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .move-display {
            font-size: 18px;
            font-weight: bold;
            color: #2196F3;
        }

        .status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }

        .status-message.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status-message.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .analysis-panel {
            background-color: #e8f4f8;
            border: 2px solid #2196F3;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }

        .analysis-panel.visible {
            display: block;
        }

        .analysis-panel h3 {
            margin-top: 0;
            color: #1976D2;
            font-size: 16px;
        }

        .evaluation-display {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            background-color: white;
        }

        .evaluation-display.positive {
            color: #2e7d32;
        }

        .evaluation-display.negative {
            color: #c62828;
        }

        .evaluation-display.neutral {
            color: #666;
        }

        .best-move-display {
            text-align: center;
            font-size: 18px;
            margin: 10px 0;
        }

        .best-move-display .label {
            font-weight: bold;
            color: #555;
        }

        .best-move-display .move {
            color: #1976D2;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        button.analyze-btn {
            background-color: #FF9800;
        }

        button.analyze-btn:hover {
            background-color: #F57C00;
        }

        button.analyze-btn:disabled {
            background-color: #cccccc;
        }

        .play-panel {
            background-color: #f0f7ff;
            border: 2px solid #1976D2;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .play-panel h3 {
            margin-top: 0;
            color: #1565C0;
            font-size: 16px;
        }

        .elo-selector {
            margin: 15px 0;
        }

        .elo-selector label {
            font-weight: bold;
            color: #555;
            display: block;
            margin-bottom: 5px;
        }

        .elo-selector select {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }

        .play-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .play-buttons button {
            flex: 1;
            background-color: #1976D2;
        }

        .play-buttons button:hover {
            background-color: #1565C0;
        }

        .game-status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
            display: none;
        }

        .game-status.visible {
            display: block;
        }

        .game-status.your-turn {
            background-color: #d4edda;
            color: #155724;
        }

        .game-status.coach-thinking {
            background-color: #fff3cd;
            color: #856404;
        }

        .game-status.game-over {
            background-color: #f8d7da;
            color: #721c24;
            font-size: 18px;
        }

        .game-analysis-panel {
            background-color: #f9fdf9;
            border: 2px solid #4CAF50;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .game-analysis-panel h3 {
            margin-top: 0;
            color: #2E7D32;
            font-size: 16px;
        }

        .analysis-button {
            background-color: #4CAF50;
            width: 100%;
            margin: 10px 0;
        }

        .analysis-button:hover {
            background-color: #45a049;
        }

        .analysis-button:disabled {
            background-color: #cccccc;
        }

        .analysis-results {
            margin-top: 15px;
            display: none;
        }

        .analysis-results.visible {
            display: block;
        }

        .accuracy-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .accuracy-box {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            text-align: center;
        }

        .accuracy-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .accuracy-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }

        .mistake-counts {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        .moves-list {
            max-height: 300px;
            overflow-y: auto;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
        }

        .move-item {
            padding: 6px;
            margin: 3px 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
        }

        .move-item:hover {
            background-color: #f5f5f5;
        }

        .move-item.excellent {
            border-left: 3px solid #2ecc71;
        }

        .move-item.good {
            border-left: 3px solid #27ae60;
        }

        .move-item.inaccuracy {
            border-left: 3px solid #f1c40f;
        }

        .move-item.mistake {
            border-left: 3px solid #e67e22;
        }

        .move-item.blunder {
            border-left: 3px solid #e74c3c;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .export-buttons button {
            flex: 1;
            background-color: #2196F3;
            font-size: 13px;
        }

        .export-buttons button:hover {
            background-color: #0b7dda;
        }

        .loading-analysis {
            text-align: center;
            padding: 30px 20px;
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            margin: 15px 0;
        }

        .loading-analysis h4 {
            margin: 0 0 15px 0;
            color: #856404;
            font-size: 16px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-details {
            color: #856404;
            font-size: 14px;
            margin: 10px 0;
        }

        /* Chat Panel Styles */
        .chat-panel {
            border: 1px solid #ccc;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            background: #f9f9f9;
            height: 600px;
        }

        .chat-header {
            padding: 10px 15px;
            background: #2c5a27;
            color: white;
            border-radius: 8px 8px 0 0;
        }

        .chat-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-message {
            padding: 10px 12px;
            border-radius: 8px;
            max-width: 85%;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.4;
            font-size: 14px;
        }

        .chat-message.user {
            background: #007bff;
            color: white;
            align-self: flex-end;
        }

        .chat-message.assistant {
            background: #e9e9e9;
            color: #333;
            align-self: flex-start;
        }

        .lesson-plan-card {
            background: #f0f7ff;
            border: 1px solid #b8d4f0;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            align-self: flex-start;
            max-width: 90%;
            font-size: 13px;
        }

        .lesson-plan-card h4 {
            margin: 0 0 8px 0;
            color: #1a5276;
            font-size: 14px;
        }

        .lesson-plan-card .lesson-type {
            display: inline-block;
            background: #1a5276;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .lesson-plan-card ul {
            margin: 4px 0;
            padding-left: 20px;
        }

        .lesson-plan-card li {
            margin: 2px 0;
        }

        .lesson-plan-card .lesson-source {
            color: #666;
            font-style: italic;
            font-size: 12px;
            margin-top: 6px;
        }

        .lesson-active-banner {
            background: #e8f5e9;
            border: 1px solid #a5d6a7;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #2e7d32;
            display: none;
        }

        .lesson-active-banner.visible {
            display: block;
        }

        .chat-message.thinking {
            background: #f0f0f0;
            color: #666;
            font-style: italic;
            align-self: flex-start;
        }

        .chat-input-area {
            padding: 10px;
            border-top: 1px solid #ccc;
            display: flex;
            gap: 8px;
        }

        .chat-input-area input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .chat-input-area button {
            padding: 10px 20px;
            background: #2c5a27;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-input-area button:hover {
            background: #1e3d1a;
        }

        .chat-input-area button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chess Coach - Interactive Board</h1>

        <div id="status" class="status-message"></div>

        <div class="main-content">
            <div class="left-column">
                <div id="board"></div>

                <div class="controls">
                    <div class="file-input-wrapper">
                        <input type="file" id="pgnFileInput" accept=".pgn" />
                        <label for="pgnFileInput">Load PGN</label>
                    </div>
                    <button id="startBtn" onclick="chessBoard.goToStart()">Start</button>
                    <button id="prevBtn" onclick="chessBoard.previousMove()">Previous</button>
                    <button id="nextBtn" onclick="chessBoard.nextMove()">Next</button>
                    <button id="endBtn" onclick="chessBoard.goToEnd()">End</button>
                    <button id="flipBtn" onclick="chessBoard.flipBoard()">Flip Board</button>
                    <button id="resetBtn" onclick="chessBoard.resetBoard()">Reset</button>
                    <button id="analyzeBtn" class="analyze-btn" onclick="analyzeCurrentPosition()">Analyze Position</button>
                </div>
            </div>

            <div class="right-column">
                <div class="info-panel">
                    <div class="info-row">
                        <span class="info-label">Move:</span>
                        <span class="info-value" id="moveNumber">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Last Move:</span>
                        <span class="info-value move-display" id="moveNotation">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Position:</span>
                        <span class="info-value" id="fenDisplay" style="font-size: 11px; word-break: break-all;">-</span>
                    </div>
                </div>

                <div id="analysisPanel" class="analysis-panel">
                    <h3>Position Analysis</h3>
                    <div id="analysisContent">
                        <div class="loading">Analyzing...</div>
                    </div>
                </div>

                <div id="playPanel" class="play-panel">
                    <h3>Play vs Coach</h3>

                    <div class="elo-selector">
                        <label for="eloSelect">Coach Strength:</label>
                        <select id="eloSelect">
                            <option value="1350">Beginner (1350)</option>
                            <option value="1500" selected>Intermediate (1500)</option>
                            <option value="1700">Advanced (1700)</option>
                            <option value="1900">Strong (1900)</option>
                            <option value="2100">Expert (2100)</option>
                            <option value="2300">Master (2300)</option>
                            <option value="2500">Grandmaster (2500)</option>
                            <option value="2800">Maximum (2800)</option>
                        </select>
                    </div>

                    <div class="play-buttons">
                        <button onclick="startGameAsWhite()">New Game as White</button>
                        <button onclick="startGameAsBlack()">New Game as Black</button>
                    </div>

                    <div id="gameStatus" class="game-status"></div>
                </div>

                <div id="gameAnalysisPanel" class="game-analysis-panel">
            <h3>Game Analysis</h3>

            <button class="analysis-button" onclick="analyzeFullGame()" id="analyzeGameBtn">
                Analyze Full Game
            </button>

            <div id="analysisResults" class="analysis-results">
                <div class="accuracy-display">
                    <div class="accuracy-box">
                        <div class="accuracy-label">White Accuracy</div>
                        <div class="accuracy-value" id="whiteAccuracy">-</div>
                        <div class="mistake-counts" id="whiteMistakes">-</div>
                    </div>
                    <div class="accuracy-box">
                        <div class="accuracy-label">Black Accuracy</div>
                        <div class="accuracy-value" id="blackAccuracy">-</div>
                        <div class="mistake-counts" id="blackMistakes">-</div>
                    </div>
                </div>

                <div id="movesList" class="moves-list"></div>

                <div class="export-buttons">
                    <button onclick="exportPlainPGN()">Export Plain PGN</button>
                    <button onclick="exportAnnotatedPGN()">Export Annotated PGN</button>
                </div>
            </div>

            <div id="loadingAnalysis" class="loading-analysis" style="display: none;">
                <h4>ðŸ¤” Analyzing Your Game...</h4>
                <div class="loading-spinner"></div>
                <div class="loading-details" id="loadingDetails">
                    Preparing analysis...
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%">
                        <span id="progressText">0%</span>
                    </div>
                </div>
                <div style="font-size: 12px; color: #856404; margin-top: 10px;">
                    This may take 1-5 minutes depending on game length
                </div>
            </div>
        </div>
            </div>

            <div class="chat-column">
                <div id="chatPanel" class="chat-panel">
                    <div class="chat-header">
                        <h3>Chess Coach</h3>
                    </div>
                    <div id="lessonBanner" class="lesson-active-banner"></div>
                    <div id="chatMessages" class="chat-messages">
                    </div>
                    <div class="chat-input-area">
                        <input type="text" id="chatInput" placeholder="Ask your coach..."
                               onkeypress="handleChatKeypress(event)">
                        <button id="chatSendBtn" onclick="sendChatMessage()">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- jQuery (required by chessboard.js) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- chessboard.js -->
    <script src="chessboard-1.0.0.min.js"></script>

    <!-- chess.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        // Chess Board Controller
        const chessBoard = (function() {
            let board = null;
            let game = new Chess();
            let moveHistory = [];
            let currentMoveIndex = -1;

            // Initialize the board
            function init() {
                const config = {
                    draggable: true,
                    position: 'start',
                    pieceTheme: 'img/chesspieces/wikipedia/{piece}.png',
                    onDragStart: onDragStart,
                    onDrop: onDrop,
                    onSnapEnd: onSnapEnd
                };

                board = Chessboard('board', config);
                updateDisplay();
                updateButtons();
            }

            // Prevent dragging pieces when stepping through history
            function onDragStart(source, piece, position, orientation) {
                // In play mode: only allow dragging on player's turn
                if (typeof isPlaying !== 'undefined' && isPlaying) {
                    if (!isPlayerTurn) return false;

                    // Only allow player to move their own pieces
                    if (playerColor === 'white' && piece.search(/^b/) !== -1) return false;
                    if (playerColor === 'black' && piece.search(/^w/) !== -1) return false;

                    return true;
                }

                // Only allow dragging if we're at the current position (end of history)
                if (currentMoveIndex < moveHistory.length - 1) {
                    return false;
                }

                // Don't allow moves if game is over
                if (game.game_over()) return false;

                // Only pick up pieces for the side to move
                if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                    (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                    return false;
                }
            }

            function onDrop(source, target) {
                // Check if in play mode - use global onDropPiece function
                if (typeof isPlaying !== 'undefined' && isPlaying) {
                    return onDropPiece(source, target);
                }

                // Normal mode: Try to make the move
                const move = game.move({
                    from: source,
                    to: target,
                    promotion: 'q' // Always promote to queen for simplicity
                });

                // Illegal move
                if (move === null) return 'snapback';

                // Add move to history
                moveHistory = moveHistory.slice(0, currentMoveIndex + 1);
                moveHistory.push({
                    move: move,
                    fen: game.fen()
                });
                currentMoveIndex++;

                updateDisplay();
                updateButtons();
            }

            function onSnapEnd() {
                board.position(game.fen());
            }

            // Update the info display
            function updateDisplay() {
                const moveNum = currentMoveIndex >= 0 ? currentMoveIndex + 1 : 0;
                const totalMoves = moveHistory.length;

                document.getElementById('moveNumber').textContent =
                    totalMoves > 0 ? `${moveNum} / ${totalMoves}` : '-';

                if (currentMoveIndex >= 0 && moveHistory[currentMoveIndex]) {
                    const move = moveHistory[currentMoveIndex].move;
                    document.getElementById('moveNotation').textContent = move.san;
                } else {
                    document.getElementById('moveNotation').textContent = '-';
                }

                document.getElementById('fenDisplay').textContent = game.fen();
            }

            // Update button states
            function updateButtons() {
                document.getElementById('startBtn').disabled = currentMoveIndex < 0;
                document.getElementById('prevBtn').disabled = currentMoveIndex < 0;
                document.getElementById('nextBtn').disabled = currentMoveIndex >= moveHistory.length - 1;
                document.getElementById('endBtn').disabled = currentMoveIndex >= moveHistory.length - 1;
            }

            // Show status message
            function showStatus(message, type = 'success') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status-message ${type}`;
                statusEl.style.display = 'block';

                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }

            // Navigation functions
            function goToStart() {
                if (moveHistory.length === 0) return;

                currentMoveIndex = -1;
                game.reset();
                board.position('start');
                updateDisplay();
                updateButtons();
            }

            function previousMove() {
                if (currentMoveIndex < 0) return;

                currentMoveIndex--;

                if (currentMoveIndex < 0) {
                    game.reset();
                    board.position('start');
                } else {
                    game.load(moveHistory[currentMoveIndex].fen);
                    board.position(moveHistory[currentMoveIndex].fen);
                }

                updateDisplay();
                updateButtons();
            }

            function nextMove() {
                if (currentMoveIndex >= moveHistory.length - 1) return;

                currentMoveIndex++;
                game.load(moveHistory[currentMoveIndex].fen);
                board.position(moveHistory[currentMoveIndex].fen);

                updateDisplay();
                updateButtons();
            }

            function goToEnd() {
                if (moveHistory.length === 0) return;

                currentMoveIndex = moveHistory.length - 1;
                game.load(moveHistory[currentMoveIndex].fen);
                board.position(moveHistory[currentMoveIndex].fen);

                updateDisplay();
                updateButtons();
            }

            function flipBoard() {
                board.flip();
            }

            function resetBoard() {
                game.reset();
                board.start();
                moveHistory = [];
                currentMoveIndex = -1;
                updateDisplay();
                updateButtons();
                showStatus('Board reset to starting position');
            }

            // Public API: Set position from FEN string
            function setPosition(fen) {
                try {
                    const tempGame = new Chess();
                    if (!tempGame.load(fen)) {
                        throw new Error('Invalid FEN');
                    }

                    game.load(fen);
                    board.position(fen);
                    moveHistory = [];
                    currentMoveIndex = -1;
                    updateDisplay();
                    updateButtons();
                    showStatus('Position set successfully');
                    return true;
                } catch (e) {
                    showStatus('Invalid FEN string: ' + e.message, 'error');
                    return false;
                }
            }

            // Public API: Make a move programmatically
            function makeMove(from, to, promotion = 'q') {
                try {
                    const move = game.move({
                        from: from,
                        to: to,
                        promotion: promotion
                    });

                    if (move === null) {
                        throw new Error('Illegal move');
                    }

                    board.position(game.fen());

                    // Add to history
                    moveHistory = moveHistory.slice(0, currentMoveIndex + 1);
                    moveHistory.push({
                        move: move,
                        fen: game.fen()
                    });
                    currentMoveIndex++;

                    updateDisplay();
                    updateButtons();
                    return move;
                } catch (e) {
                    showStatus('Invalid move: ' + e.message, 'error');
                    return null;
                }
            }

            // Public API: Load PGN from string
            function loadPGN(pgnString) {
                try {
                    const tempGame = new Chess();
                    if (!tempGame.load_pgn(pgnString)) {
                        throw new Error('Invalid PGN');
                    }

                    // Reset everything
                    game.reset();
                    moveHistory = [];
                    currentMoveIndex = -1;

                    // Parse the PGN and build move history
                    const moves = tempGame.history({ verbose: true });
                    game.reset();

                    for (let i = 0; i < moves.length; i++) {
                        const move = game.move(moves[i].san);
                        moveHistory.push({
                            move: move,
                            fen: game.fen()
                        });
                    }

                    // Go to start position
                    game.reset();
                    board.start();
                    currentMoveIndex = -1;

                    updateDisplay();
                    updateButtons();
                    showStatus(`PGN loaded successfully (${moveHistory.length} moves)`);
                    return true;
                } catch (e) {
                    showStatus('Failed to load PGN: ' + e.message, 'error');
                    return false;
                }
            }

            // Handle file input
            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const pgnText = e.target.result;
                    loadPGN(pgnText);
                };
                reader.readAsText(file);

                // Reset the file input so the same file can be loaded again
                event.target.value = '';
            }

            // Get current FEN
            function getCurrentFEN() {
                return game.fen();
            }

            function getPGN() {
                // If there's no move history, return current game state
                if (moveHistory.length === 0) {
                    return game.pgn();
                }

                // Rebuild PGN from move history
                const tempGame = new Chess();
                for (let i = 0; i < moveHistory.length; i++) {
                    tempGame.move(moveHistory[i].move.san);
                }
                return tempGame.pgn();
            }

            // Public interface
            return {
                init: init,
                setPosition: setPosition,
                makeMove: makeMove,
                loadPGN: loadPGN,
                goToStart: goToStart,
                previousMove: previousMove,
                nextMove: nextMove,
                goToEnd: goToEnd,
                flipBoard: flipBoard,
                resetBoard: resetBoard,
                handleFileSelect: handleFileSelect,
                getCurrentFEN: getCurrentFEN,
                getPGN: getPGN
            };
        })();

        // Initialize when page loads
        $(document).ready(function() {
            chessBoard.init();

            // Set up file input handler
            document.getElementById('pgnFileInput').addEventListener('change', chessBoard.handleFileSelect);
        });

        // Keyboard shortcuts (skip when typing in chat input)
        document.addEventListener('keydown', function(e) {
            if (document.activeElement && document.activeElement.id === 'chatInput') return;

            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    chessBoard.previousMove();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    chessBoard.nextMove();
                    break;
                case 'Home':
                    e.preventDefault();
                    chessBoard.goToStart();
                    break;
                case 'End':
                    e.preventDefault();
                    chessBoard.goToEnd();
                    break;
            }
        });

        // Position Analysis Functions
        const API_BASE_URL = 'http://localhost:8000';

        async function analyzeCurrentPosition() {
            const analysisPanel = document.getElementById('analysisPanel');
            const analysisContent = document.getElementById('analysisContent');
            const analyzeBtn = document.getElementById('analyzeBtn');

            // Get current FEN
            const fen = chessBoard.getCurrentFEN();

            // Show analysis panel with loading state
            analysisPanel.classList.add('visible');
            analysisContent.innerHTML = '<div class="loading">Analyzing position...</div>';
            analyzeBtn.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fen: fen,
                        depth: 15
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Analysis failed');
                }

                const data = await response.json();
                displayAnalysis(data);

            } catch (error) {
                analysisContent.innerHTML = `
                    <div class="error" style="color: #c62828; text-align: center;">
                        <strong>Error:</strong> ${error.message}
                        <br><small>Make sure the backend server is running on port 8000</small>
                    </div>
                `;
            } finally {
                analyzeBtn.disabled = false;
            }
        }

        function displayAnalysis(data) {
            const analysisContent = document.getElementById('analysisContent');
            const { evaluation, best_move_san } = data;

            // Format evaluation
            let evalText = '';
            let evalClass = 'neutral';

            if (evaluation.type === 'mate') {
                const mateValue = evaluation.value;
                if (mateValue > 0) {
                    evalText = `M${Math.abs(mateValue)}`;
                    evalClass = 'positive';
                } else {
                    evalText = `M-${Math.abs(mateValue)}`;
                    evalClass = 'negative';
                }
            } else {
                // Centipawn evaluation
                const cpValue = evaluation.value;
                if (cpValue > 0) {
                    evalText = `+${cpValue.toFixed(2)}`;
                    evalClass = 'positive';
                } else if (cpValue < 0) {
                    evalText = cpValue.toFixed(2);
                    evalClass = 'negative';
                } else {
                    evalText = '0.00';
                    evalClass = 'neutral';
                }
            }

            // Build HTML
            let html = `
                <div class="evaluation-display ${evalClass}">
                    ${evalText}
                </div>
            `;

            if (best_move_san) {
                html += `
                    <div class="best-move-display">
                        <span class="label">Best move:</span>
                        <span class="move">${best_move_san}</span>
                    </div>
                `;
            }

            html += `
                <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                    Depth: ${data.depth}
                </div>
            `;

            analysisContent.innerHTML = html;
        }

        // Play vs Coach Mode
        let isPlaying = false;
        let playerColor = null;  // 'white' or 'black'
        let isPlayerTurn = false;

        function startGameAsWhite() {
            // Reset game
            chessBoard.resetBoard();
            isPlaying = true;
            playerColor = 'white';
            isPlayerTurn = true;

            updateGameStatus("Your turn (White)");
            showStatus('New game started - You are White');

            // Hide analysis panel
            document.getElementById('analysisPanel').classList.remove('visible');
        }

        function startGameAsBlack() {
            // Reset game
            chessBoard.resetBoard();
            isPlaying = true;
            playerColor = 'black';
            isPlayerTurn = false;

            updateGameStatus("Coach thinking...");
            showStatus('New game started - You are Black');

            // Hide analysis panel
            document.getElementById('analysisPanel').classList.remove('visible');

            // Coach (White) makes first move
            setTimeout(() => requestCoachMove(), 500);
        }

        async function requestCoachMove() {
            if (!isPlaying) return;

            const fen = chessBoard.getCurrentFEN();
            const elo = parseInt(document.getElementById('eloSelect').value);

            updateGameStatus("Coach thinking...", "coach-thinking");

            try {
                const response = await fetch(`${API_BASE_URL}/api/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ fen, elo })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Failed to get coach move');
                }

                const data = await response.json();

                // Apply coach's move
                const move = data.move;
                const from = move.substring(0, 2);
                const to = move.substring(2, 4);
                const promotion = move.length > 4 ? move[4] : 'q';

                chessBoard.makeMove(from, to, promotion);

                // Check if game is over
                const gameResult = checkGameOver();
                if (gameResult) {
                    endGame(gameResult);
                } else {
                    isPlayerTurn = true;
                    updateGameStatus(`Your turn (${playerColor === 'white' ? 'White' : 'Black'})`, "your-turn");
                }

            } catch (error) {
                updateGameStatus("Error: " + error.message, "game-over");
                isPlaying = false;
            }
        }

        function onDropPiece(source, target) {
            // Only allow moves when it's player's turn in play mode
            if (isPlaying && !isPlayerTurn) {
                return 'snapback';
            }

            // Try to make the move
            const move = chessBoard.makeMove(source, target);

            if (move === null && isPlaying) {
                return 'snapback';
            }

            if (isPlaying && move !== null) {
                isPlayerTurn = false;

                // Check if game is over
                const gameResult = checkGameOver();
                if (gameResult) {
                    endGame(gameResult);
                } else {
                    // Request coach's move
                    setTimeout(() => requestCoachMove(), 500);
                }
            }
        }

        function checkGameOver() {
            const fen = chessBoard.getCurrentFEN();
            const game = new Chess(fen);

            if (game.in_checkmate()) {
                // Whoever just moved wins (it's now the other player's turn)
                const winner = game.turn() === 'w' ? 'Black' : 'White';
                return `Checkmate! ${winner} wins!`;
            } else if (game.in_stalemate()) {
                return 'Stalemate! Draw.';
            } else if (game.in_threefold_repetition()) {
                return 'Draw by threefold repetition.';
            } else if (game.in_draw()) {
                return 'Draw!';
            }

            return null;
        }

        function endGame(result) {
            isPlaying = false;
            isPlayerTurn = false;
            updateGameStatus(result, "game-over");
        }

        function updateGameStatus(message, className = "your-turn") {
            const statusDiv = document.getElementById('gameStatus');
            statusDiv.textContent = message;
            statusDiv.className = `game-status visible ${className}`;
        }

        // Game Analysis Functions
        let currentGameAnalysis = null;

        async function analyzeFullGame() {
            // Get PGN from current game
            const pgn = chessBoard.getPGN();
            if (!pgn || pgn.trim() === '') {
                alert('No game loaded. Please load a PGN file or play a game first.');
                return;
            }

            // Estimate move count from PGN (rough estimate)
            const moveMatches = pgn.match(/\d+\./g);
            const estimatedMoves = moveMatches ? moveMatches.length * 2 : 40;
            const estimatedSeconds = estimatedMoves * 2.5; // ~2.5 seconds per move at depth 15
            const estimatedMinutes = Math.ceil(estimatedSeconds / 60);

            // Show loading state
            document.getElementById('analyzeGameBtn').disabled = true;
            document.getElementById('loadingAnalysis').style.display = 'block';
            document.getElementById('analysisResults').classList.remove('visible');

            // Update loading details
            const detailsDiv = document.getElementById('loadingDetails');
            detailsDiv.textContent = `Analyzing ~${estimatedMoves} moves (estimated time: ${estimatedMinutes} ${estimatedMinutes === 1 ? 'minute' : 'minutes'})`;

            // Start progress simulation
            let progress = 0;
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');

            const progressInterval = setInterval(() => {
                if (progress < 90) {
                    // Gradually increase to 90% (leave 10% for final processing)
                    progress += Math.random() * 3;
                    progress = Math.min(progress, 90);
                    progressBar.style.width = progress + '%';
                    progressText.textContent = Math.floor(progress) + '%';
                }
            }, 500);

            try {
                const startTime = Date.now();

                const response = await fetch(`${API_BASE_URL}/api/game/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        pgn: pgn,
                        depth: 15  // Default depth
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Analysis failed');
                }

                const analysisData = await response.json();

                // Complete the progress bar
                clearInterval(progressInterval);
                progressBar.style.width = '100%';
                progressText.textContent = '100%';

                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                detailsDiv.textContent = `Analysis complete! (${elapsedSeconds} seconds, ${analysisData.summary.total_moves} moves analyzed)`;

                // Wait a moment to show completion
                await new Promise(resolve => setTimeout(resolve, 500));

                currentGameAnalysis = analysisData;
                displayGameAnalysis(analysisData);

            } catch (error) {
                clearInterval(progressInterval);
                console.error('Game analysis error:', error);
                alert(`Analysis failed: ${error.message}`);
            } finally {
                document.getElementById('analyzeGameBtn').disabled = false;
                document.getElementById('loadingAnalysis').style.display = 'none';

                // Reset progress bar
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
            }
        }

        function displayGameAnalysis(data) {
            // Show results panel
            document.getElementById('analysisResults').classList.add('visible');

            // Display accuracy
            document.getElementById('whiteAccuracy').textContent = data.summary.white_accuracy.toFixed(1) + '%';
            document.getElementById('blackAccuracy').textContent = data.summary.black_accuracy.toFixed(1) + '%';

            // Display mistake counts
            document.getElementById('whiteMistakes').textContent =
                `Blunders: ${data.summary.white_blunders} | Mistakes: ${data.summary.white_mistakes} | Inaccuracies: ${data.summary.white_inaccuracies}`;
            document.getElementById('blackMistakes').textContent =
                `Blunders: ${data.summary.black_blunders} | Mistakes: ${data.summary.black_mistakes} | Inaccuracies: ${data.summary.black_inaccuracies}`;

            // Build moves list
            const movesList = document.getElementById('movesList');
            movesList.innerHTML = '';

            data.moves.forEach((move, index) => {
                const moveItem = document.createElement('div');
                moveItem.className = `move-item ${move.classification}`;

                const moveText = move.color === 'white'
                    ? `${move.move_number}. ${move.move_san}`
                    : `${move.move_number}... ${move.move_san}`;

                const evalText = move.eval_after !== null
                    ? ` (${move.eval_after > 0 ? '+' : ''}${move.eval_after.toFixed(2)})`
                    : '';

                moveItem.textContent = `${moveText}${evalText} - ${move.classification}`;

                // Make clickable to jump to position
                moveItem.onclick = () => {
                    chessBoard.setPosition(move.fen_after);
                };

                // Add tooltip with best move for non-excellent moves
                if (move.classification !== 'excellent' && move.classification !== 'good') {
                    moveItem.title = `Best: ${move.best_move_san} (eval change: ${move.eval_change.toFixed(2)})`;
                }

                movesList.appendChild(moveItem);
            });
        }

        function exportPlainPGN() {
            const pgn = chessBoard.getPGN();
            if (!pgn || pgn.trim() === '') {
                alert('No game to export. Please load a PGN file or play a game first.');
                return;
            }

            const filename = `game_${new Date().toISOString().slice(0, 10)}.pgn`;
            downloadPGN(pgn, filename);
        }

        function exportAnnotatedPGN() {
            if (!currentGameAnalysis || !currentGameAnalysis.moves) {
                alert('Please analyze the game first before exporting annotated PGN.');
                return;
            }

            const pgn = generateAnnotatedPGN(currentGameAnalysis.moves);
            const filename = `game_annotated_${new Date().toISOString().slice(0, 10)}.pgn`;
            downloadPGN(pgn, filename);
        }

        function generateAnnotatedPGN(moves) {
            let pgn = '';
            let moveNumber = 1;

            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];

                // Add move number for white's move
                if (move.color === 'white') {
                    pgn += `${moveNumber}. `;
                }

                // Add the move
                pgn += move.move_san;

                // Add annotation based on classification
                if (move.classification === 'blunder') {
                    pgn += '??';
                } else if (move.classification === 'mistake') {
                    pgn += '?';
                } else if (move.classification === 'inaccuracy') {
                    pgn += '?!';
                } else if (move.classification === 'excellent') {
                    pgn += '!';
                }

                // Add evaluation and best move comment for non-good moves
                if (['blunder', 'mistake', 'inaccuracy'].includes(move.classification)) {
                    const evalBefore = move.eval_before !== null ? move.eval_before.toFixed(2) : '?';
                    const evalAfter = move.eval_after !== null ? move.eval_after.toFixed(2) : '?';
                    pgn += ` {${move.classification}. ${evalBefore} â†’ ${evalAfter}. Best: ${move.best_move_san}}`;
                } else {
                    const evalAfter = move.eval_after !== null ? move.eval_after.toFixed(2) : '?';
                    pgn += ` {${evalAfter > 0 ? '+' : ''}${evalAfter}}`;
                }

                pgn += ' ';

                // Increment move number after black's move
                if (move.color === 'black') {
                    moveNumber++;
                }
            }

            return pgn.trim();
        }

        function downloadPGN(content, filename) {
            const blob = new Blob([content], { type: 'application/x-chess-pgn' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ===== Chat Functions =====
        let conversationHistory = [];
        let currentLessonPlan = null;

        function initChat() {
            addChatMessage('assistant', "Hi! I'm your chess coach. What would you like to work on today?");
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSendBtn');
            const message = input.value.trim();

            if (!message) return;

            // Clear input and disable send
            input.value = '';
            sendBtn.disabled = true;

            // Display user message
            addChatMessage('user', message);

            // Show thinking indicator
            const thinkingId = addChatMessage('assistant', 'Thinking...', true);

            // Gather board context
            const boardContext = {
                fen: chessBoard.getCurrentFEN(),
                last_move: document.getElementById('moveNotation').textContent !== '-'
                    ? document.getElementById('moveNotation').textContent
                    : null,
                mode: getCurrentMode()
            };

            try {
                const response = await fetch(`${API_BASE_URL}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        conversation_history: conversationHistory,
                        board_context: boardContext
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Failed to get response');
                }

                const data = await response.json();

                // Remove thinking indicator, show real response
                removeChatMessage(thinkingId);
                addChatMessage('assistant', data.message);

                // Handle lesson plan if present
                if (data.suggested_action && data.suggested_action.type === 'start_lesson') {
                    currentLessonPlan = data.suggested_action.lesson_plan;
                    displayLessonPlan(currentLessonPlan);
                }

                // Update conversation history
                conversationHistory.push({ role: 'user', content: message });
                conversationHistory.push({ role: 'assistant', content: data.message });

            } catch (error) {
                removeChatMessage(thinkingId);
                addChatMessage('assistant', 'Sorry, I had trouble responding. Please try again.');
                console.error('Chat error:', error);
            } finally {
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function addChatMessage(role, content, isThinking = false) {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            const messageId = 'msg-' + Date.now();

            messageDiv.id = messageId;
            messageDiv.className = `chat-message ${role}${isThinking ? ' thinking' : ''}`;
            messageDiv.textContent = content;

            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            return messageId;
        }

        function removeChatMessage(messageId) {
            const el = document.getElementById(messageId);
            if (el) el.remove();
        }

        function handleChatKeypress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        function getCurrentMode() {
            if (currentLessonPlan) return 'lesson';
            if (typeof isPlaying !== 'undefined' && isPlaying) return 'play';
            const analysisPanel = document.getElementById('analysisPanel');
            if (analysisPanel && analysisPanel.classList.contains('visible')) return 'analysis';
            return 'idle';
        }

        function displayLessonPlan(plan) {
            const messagesDiv = document.getElementById('chatMessages');
            const card = document.createElement('div');
            card.className = 'lesson-plan-card';

            const goalsHtml = plan.goals
                ? plan.goals.map(g => `<li>${g}</li>`).join('')
                : '';

            let sourceHtml = '';
            if (plan.source_reference) {
                const ref = plan.source_reference;
                const parts = [ref.book, ref.chapter, ref.section].filter(Boolean);
                if (parts.length) {
                    sourceHtml = `<div class="lesson-source">Source: ${parts.join(' > ')}</div>`;
                }
            }

            card.innerHTML = `
                <h4>Lesson: ${plan.topic || 'Practice Session'}</h4>
                <span class="lesson-type">${(plan.type || plan.activity?.type || '').replace(/_/g, ' ')}</span>
                ${goalsHtml ? `<ul>${goalsHtml}</ul>` : ''}
                ${sourceHtml}
            `;

            messagesDiv.appendChild(card);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Show lesson banner
            const banner = document.getElementById('lessonBanner');
            banner.textContent = 'Lesson active: ' + (plan.topic || 'Practice Session');
            banner.classList.add('visible');
        }

        // Initialize chat on page load
        $(document).ready(function() {
            initChat();
        });
    </script>
</body>
</html>
