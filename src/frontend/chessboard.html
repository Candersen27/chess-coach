<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Coach - Interactive Chessboard</title>

    <!-- chessboard.js CSS -->
    <link rel="stylesheet" href="chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-top: 0;
            text-align: center;
        }

        .main-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .left-column {
            flex: 0 0 550px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-column {
            flex: 1;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chat-column {
            flex: 0 0 350px;
            display: flex;
            flex-direction: column;
        }

        #board {
            width: 500px;
            height: 500px;
            margin: 0 auto;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-wrapper label {
            display: inline-block;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 4px;
            background-color: #2196F3;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-input-wrapper label:hover {
            background-color: #0b7dda;
        }

        .info-panel {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
        }

        .info-label {
            font-weight: bold;
            color: #555;
        }

        .info-value {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .move-display {
            font-size: 18px;
            font-weight: bold;
            color: #2196F3;
        }

        .status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }

        .status-message.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status-message.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .analysis-panel {
            background-color: #e8f4f8;
            border: 2px solid #2196F3;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
            display: none;
        }

        .analysis-panel.visible {
            display: block;
        }

        .analysis-panel h3 {
            margin-top: 0;
            color: #1976D2;
            font-size: 16px;
        }

        .evaluation-display {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            background-color: white;
        }

        .evaluation-display.positive {
            color: #2e7d32;
        }

        .evaluation-display.negative {
            color: #c62828;
        }

        .evaluation-display.neutral {
            color: #666;
        }

        .best-move-display {
            text-align: center;
            font-size: 18px;
            margin: 10px 0;
        }

        .best-move-display .label {
            font-weight: bold;
            color: #555;
        }

        .best-move-display .move {
            color: #1976D2;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        button.analyze-btn {
            background-color: #FF9800;
        }

        button.analyze-btn:hover {
            background-color: #F57C00;
        }

        button.analyze-btn:disabled {
            background-color: #cccccc;
        }

        .play-panel {
            background-color: #f0f7ff;
            border: 2px solid #1976D2;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .play-panel h3 {
            margin-top: 0;
            color: #1565C0;
            font-size: 16px;
        }

        .elo-selector {
            margin: 15px 0;
        }

        .elo-selector label {
            font-weight: bold;
            color: #555;
            display: block;
            margin-bottom: 5px;
        }

        .elo-selector select {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }

        .play-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .play-buttons button {
            flex: 1;
            background-color: #1976D2;
        }

        .play-buttons button:hover {
            background-color: #1565C0;
        }

        .game-status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
            display: none;
        }

        .game-status.visible {
            display: block;
        }

        .game-status.your-turn {
            background-color: #d4edda;
            color: #155724;
        }

        .game-status.coach-thinking {
            background-color: #fff3cd;
            color: #856404;
        }

        .game-status.game-over {
            background-color: #f8d7da;
            color: #721c24;
            font-size: 18px;
        }

        .game-analysis-panel {
            background-color: #f9fdf9;
            border: 2px solid #4CAF50;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }

        .game-analysis-panel h3 {
            margin-top: 0;
            color: #2E7D32;
            font-size: 16px;
        }

        .analysis-button {
            background-color: #4CAF50;
            width: 100%;
            margin: 10px 0;
        }

        .analysis-button:hover {
            background-color: #45a049;
        }

        .analysis-button:disabled {
            background-color: #cccccc;
        }

        .analysis-results {
            margin-top: 15px;
            display: none;
        }

        .analysis-results.visible {
            display: block;
        }

        .accuracy-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }

        .accuracy-box {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            text-align: center;
        }

        .accuracy-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .accuracy-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }

        .mistake-counts {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        .moves-list {
            max-height: 300px;
            overflow-y: auto;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
        }

        .move-item {
            padding: 6px;
            margin: 3px 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
        }

        .move-item:hover {
            background-color: #f5f5f5;
        }

        .move-item.excellent {
            border-left: 3px solid #2ecc71;
        }

        .move-item.good {
            border-left: 3px solid #27ae60;
        }

        .move-item.inaccuracy {
            border-left: 3px solid #f1c40f;
        }

        .move-item.mistake {
            border-left: 3px solid #e67e22;
        }

        .move-item.blunder {
            border-left: 3px solid #e74c3c;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .export-buttons button {
            flex: 1;
            background-color: #2196F3;
            font-size: 13px;
        }

        .export-buttons button:hover {
            background-color: #0b7dda;
        }

        .loading-analysis {
            text-align: center;
            padding: 30px 20px;
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            margin: 15px 0;
        }

        .loading-analysis h4 {
            margin: 0 0 15px 0;
            color: #856404;
            font-size: 16px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-details {
            color: #856404;
            font-size: 14px;
            margin: 10px 0;
        }

        /* Chat Panel Styles */
        .chat-panel {
            border: 1px solid #ccc;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            background: #f9f9f9;
            height: 600px;
        }

        .chat-header {
            padding: 10px 15px;
            background: #2c5a27;
            color: white;
            border-radius: 8px 8px 0 0;
        }

        .chat-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-message {
            padding: 10px 12px;
            border-radius: 8px;
            max-width: 85%;
            word-wrap: break-word;
            white-space: pre-wrap;
            line-height: 1.4;
            font-size: 14px;
        }

        .chat-message.user {
            background: #007bff;
            color: white;
            align-self: flex-end;
        }

        .chat-message.assistant {
            background: #e9e9e9;
            color: #333;
            align-self: flex-start;
        }

        .lesson-plan-card {
            background: #f0f7ff;
            border: 1px solid #b8d4f0;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            align-self: flex-start;
            max-width: 90%;
            font-size: 13px;
        }

        .lesson-plan-card h4 {
            margin: 0 0 8px 0;
            color: #1a5276;
            font-size: 14px;
        }

        .lesson-plan-card .lesson-type {
            display: inline-block;
            background: #1a5276;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .lesson-plan-card ul {
            margin: 4px 0;
            padding-left: 20px;
        }

        .lesson-plan-card li {
            margin: 2px 0;
        }

        .lesson-plan-card .lesson-source {
            color: #666;
            font-style: italic;
            font-size: 12px;
            margin-top: 6px;
        }

        .lesson-active-banner {
            background: #e8f5e9;
            border: 1px solid #a5d6a7;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #2e7d32;
            display: none;
        }

        .lesson-active-banner.visible {
            display: block;
        }

        .chat-message.thinking {
            background: #f0f0f0;
            color: #666;
            font-style: italic;
            align-self: flex-start;
        }

        .chat-input-area {
            padding: 10px;
            border-top: 1px solid #ccc;
            display: flex;
            gap: 8px;
        }

        .chat-input-area input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .chat-input-area button {
            padding: 10px 20px;
            background: #2c5a27;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .chat-input-area button:hover {
            background: #1e3d1a;
        }

        .chat-input-area button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        /* Tab Bar */
        .tab-bar {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #ddd;
            margin-bottom: 15px;
        }

        .tab-btn {
            padding: 8px 16px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            transition: color 0.2s, border-color 0.2s;
        }

        .tab-btn:hover {
            color: #333;
            background: none;
        }

        .tab-btn.active {
            color: #1976D2;
            border-bottom-color: #1976D2;
            font-weight: bold;
            background: none;
        }

        /* Batch Analysis */
        .batch-analysis-container {
            padding: 0;
        }

        .batch-input-section {
            margin-bottom: 20px;
        }

        .batch-input-section label {
            display: block;
            font-weight: bold;
            color: #555;
            margin-bottom: 8px;
            font-size: 14px;
        }

        #pgn-batch-input {
            width: 100%;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            box-sizing: border-box;
        }

        .batch-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .batch-controls .btn-primary {
            background-color: #1976D2;
        }

        .batch-controls .btn-primary:hover {
            background-color: #1565C0;
        }

        .batch-controls .btn-secondary {
            background-color: #757575;
        }

        .batch-controls .btn-secondary:hover {
            background-color: #616161;
        }

        .batch-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }

        .batch-status.loading {
            display: block;
            background: #e3f2fd;
            color: #1976d2;
        }

        .batch-status.error {
            display: block;
            background: #ffebee;
            color: #c62828;
        }

        .batch-status.success {
            display: block;
            background: #e8f5e9;
            color: #2e7d32;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            display: block;
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .recommendations-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 4px 4px 0;
        }

        .recommendations-box h5 {
            margin-top: 0;
            color: #e65100;
        }

        #recommendations-list {
            margin: 10px 0 0 0;
            padding-left: 20px;
        }

        #recommendations-list li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .patterns-detail, .phase-analysis {
            margin-bottom: 20px;
        }

        .patterns-detail h5, .phase-analysis h5 {
            color: #333;
            margin-bottom: 10px;
        }

        .pattern-item {
            background: #f5f5f5;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .pattern-item h6 {
            margin: 0 0 8px 0;
            color: #d32f2f;
            font-size: 13px;
        }

        .pattern-instance {
            font-size: 13px;
            margin-bottom: 5px;
            padding-left: 10px;
            color: #555;
        }

        .phase-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f5f5f5;
            margin-bottom: 8px;
            border-radius: 4px;
        }

        .phase-name {
            font-weight: bold;
            text-transform: capitalize;
        }

        .phase-accuracy {
            font-size: 18px;
            color: #1976d2;
            font-weight: bold;
        }

        .phase-errors {
            font-size: 12px;
            color: #666;
            margin-left: 10px;
        }

        .export-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .export-controls button {
            background-color: #757575;
            font-size: 13px;
        }

        .export-controls button:hover {
            background-color: #616161;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            justify-content: center;
        }

        .mode-btn {
            flex: 0 1 auto;
            padding: 8px 16px;
            border: 2px solid #ccc;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s;
            color: #333;
        }

        .mode-btn.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .mode-btn:hover:not(.active) {
            background: #f0f0f0;
        }

        .mode-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Coach Demo annotation */
        .annotation-panel {
            background-color: #fff8e1;
            border: 1px solid #ffcc02;
            border-radius: 4px;
            padding: 10px 12px;
            margin-top: 8px;
            font-size: 13px;
            color: #5d4037;
            display: none;
        }

        .annotation-panel.visible {
            display: block;
        }

        /* Coach thinking indicator in chat */
        .coach-thinking-indicator {
            background: #fff3cd;
            color: #856404;
            font-style: italic;
            padding: 10px 12px;
            border-radius: 8px;
            align-self: flex-start;
            max-width: 85%;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chess Coach - Interactive Board</h1>

        <div id="status" class="status-message"></div>

        <div class="main-content">
            <div class="left-column">
                <div class="mode-toggle">
                    <button id="myGameMode" class="mode-btn active" onclick="switchToMyGame()">My Game</button>
                    <button id="coachDemoMode" class="mode-btn" onclick="switchToCoachDemoManual()" disabled>Coach Demo</button>
                </div>

                <div id="board"></div>

                <div id="annotationPanel" class="annotation-panel"></div>

                <div class="controls">
                    <div class="file-input-wrapper">
                        <input type="file" id="pgnFileInput" accept=".pgn" />
                        <label for="pgnFileInput">Load PGN</label>
                    </div>
                    <button id="startBtn" onclick="chessBoard.goToStart()">Start</button>
                    <button id="prevBtn" onclick="chessBoard.previousMove()">Previous</button>
                    <button id="nextBtn" onclick="chessBoard.nextMove()">Next</button>
                    <button id="endBtn" onclick="chessBoard.goToEnd()">End</button>
                    <button id="flipBtn" onclick="chessBoard.flipBoard()">Flip Board</button>
                    <button id="resetBtn" onclick="chessBoard.resetBoard()">Reset</button>
                    <button id="analyzeBtn" class="analyze-btn" onclick="analyzeCurrentPosition()">Analyze Position</button>
                </div>
            </div>

            <div class="right-column">
                <div class="tab-bar">
                    <button class="tab-btn active" onclick="switchTab('tools')" data-tab="tools">Board Tools</button>
                    <button class="tab-btn" onclick="switchTab('batch')" data-tab="batch">Batch Analysis</button>
                </div>

                <div id="toolsTab">
                <div class="info-panel">
                    <div class="info-row">
                        <span class="info-label">Move:</span>
                        <span class="info-value" id="moveNumber">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Last Move:</span>
                        <span class="info-value move-display" id="moveNotation">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Position:</span>
                        <span class="info-value" id="fenDisplay" style="font-size: 11px; word-break: break-all;">-</span>
                    </div>
                </div>

                <div id="analysisPanel" class="analysis-panel">
                    <h3>Position Analysis</h3>
                    <div id="analysisContent">
                        <div class="loading">Analyzing...</div>
                    </div>
                </div>

                <div id="playPanel" class="play-panel">
                    <h3>Play vs Coach</h3>

                    <div class="elo-selector">
                        <label for="eloSelect">Coach Strength:</label>
                        <select id="eloSelect">
                            <option value="1350">Beginner (1350)</option>
                            <option value="1500" selected>Intermediate (1500)</option>
                            <option value="1700">Advanced (1700)</option>
                            <option value="1900">Strong (1900)</option>
                            <option value="2100">Expert (2100)</option>
                            <option value="2300">Master (2300)</option>
                            <option value="2500">Grandmaster (2500)</option>
                            <option value="2800">Maximum (2800)</option>
                        </select>
                    </div>

                    <div class="play-buttons">
                        <button onclick="startGameAsWhite()">New Game as White</button>
                        <button onclick="startGameAsBlack()">New Game as Black</button>
                    </div>

                    <div id="gameActions" class="play-buttons" style="display: none;">
                        <button onclick="offerDraw()" id="drawBtn" style="background-color: #f59e0b;">Draw</button>
                        <button onclick="resignGame()" id="resignBtn" style="background-color: #c62828;">Resign</button>
                    </div>

                    <div id="gameStatus" class="game-status"></div>
                </div>

                <div id="gameAnalysisPanel" class="game-analysis-panel">
            <h3>Game Analysis</h3>

            <button class="analysis-button" onclick="analyzeFullGame()" id="analyzeGameBtn">
                Analyze Full Game
            </button>

            <div id="analysisResults" class="analysis-results">
                <div class="accuracy-display">
                    <div class="accuracy-box">
                        <div class="accuracy-label">White Accuracy</div>
                        <div class="accuracy-value" id="whiteAccuracy">-</div>
                        <div class="mistake-counts" id="whiteMistakes">-</div>
                    </div>
                    <div class="accuracy-box">
                        <div class="accuracy-label">Black Accuracy</div>
                        <div class="accuracy-value" id="blackAccuracy">-</div>
                        <div class="mistake-counts" id="blackMistakes">-</div>
                    </div>
                </div>

                <div id="movesList" class="moves-list"></div>

                <div class="export-buttons">
                    <button onclick="exportPlainPGN()">Export Plain PGN</button>
                    <button onclick="exportAnnotatedPGN()">Export Annotated PGN</button>
                </div>
            </div>

            <div id="loadingAnalysis" class="loading-analysis" style="display: none;">
                <h4>ðŸ¤” Analyzing Your Game...</h4>
                <div class="loading-spinner"></div>
                <div class="loading-details" id="loadingDetails">
                    Preparing analysis...
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%">
                        <span id="progressText">0%</span>
                    </div>
                </div>
                <div style="font-size: 12px; color: #856404; margin-top: 10px;">
                    This may take 1-5 minutes depending on game length
                </div>
            </div>
        </div>
            </div><!-- end toolsTab -->

            <div id="batchTab" style="display: none;">
                <div class="batch-analysis-container">
                    <h3 style="margin-top: 0; color: #1565C0;">Multi-Game Pattern Analysis</h3>

                    <div class="batch-input-section">
                        <label for="batch-username">
                            Your username (as it appears in PGN headers)
                        </label>
                        <input type="text" id="batch-username"
                            placeholder="e.g. MyChessName"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; box-sizing: border-box; margin-bottom: 12px;">

                        <label for="pgn-batch-input">
                            Paste 5-10 games (PGN format, separated by [Event] headers)
                        </label>
                        <textarea
                            id="pgn-batch-input"
                            rows="12"
                            placeholder="[Event &quot;Game 1&quot;]&#10;[White &quot;You&quot;]&#10;[Black &quot;Opponent&quot;]&#10;[Result &quot;0-1&quot;]&#10;&#10;1. e4 e5 2. Nf3 Nc6...&#10;&#10;[Event &quot;Game 2&quot;]&#10;1. d4 d5 2. c4 e6..."></textarea>

                        <div class="batch-controls">
                            <button id="analyze-batch-btn" class="btn-primary">Analyze Games</button>
                            <button id="clear-batch-btn" class="btn-secondary">Clear</button>
                        </div>

                        <div id="batch-status" class="batch-status"></div>
                    </div>

                    <div id="pattern-summary" style="display: none;">
                        <div class="summary-stats">
                            <div class="stat-card">
                                <span class="stat-label">Games Analyzed</span>
                                <span class="stat-value" id="total-games">0</span>
                            </div>
                            <div class="stat-card">
                                <span class="stat-label">Overall Accuracy</span>
                                <span class="stat-value" id="overall-accuracy">0%</span>
                            </div>
                        </div>

                        <div class="recommendations-box">
                            <h5>Top Recommendations</h5>
                            <ul id="recommendations-list"></ul>
                        </div>

                        <div class="patterns-detail">
                            <h5>Tactical Patterns Found</h5>
                            <div id="tactical-patterns"></div>
                        </div>

                        <div class="phase-analysis">
                            <h5>Performance by Phase</h5>
                            <div id="phase-stats"></div>
                        </div>

                        <div class="export-controls">
                            <button id="export-analysis-btn">Export Analysis</button>
                            <button id="import-analysis-btn">Import Analysis</button>
                            <input type="file" id="import-file" accept=".json" style="display: none;">
                        </div>
                    </div>
                </div>
            </div><!-- end batchTab -->

            </div>

            <div class="chat-column">
                <div id="chatPanel" class="chat-panel">
                    <div class="chat-header">
                        <h3>Chess Coach</h3>
                    </div>
                    <div id="lessonBanner" class="lesson-active-banner"></div>
                    <div id="chatMessages" class="chat-messages">
                    </div>
                    <div class="chat-input-area">
                        <input type="text" id="chatInput" placeholder="Ask your coach..."
                               onkeypress="handleChatKeypress(event)">
                        <button id="chatSendBtn" onclick="sendChatMessage()">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- jQuery (required by chessboard.js) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- chessboard.js -->
    <script src="chessboard-1.0.0.min.js"></script>

    <!-- chess.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        // Chess Board Controller
        const chessBoard = (function() {
            let board = null;
            let game = new Chess();
            let moveHistory = [];
            let currentMoveIndex = -1;

            // Initialize the board
            function init() {
                const config = {
                    draggable: true,
                    position: 'start',
                    pieceTheme: 'img/chesspieces/wikipedia/{piece}.png',
                    onDragStart: onDragStart,
                    onDrop: onDrop,
                    onSnapEnd: onSnapEnd
                };

                board = Chessboard('board', config);
                updateDisplay();
                updateButtons();
            }

            // Prevent dragging pieces when stepping through history
            function onDragStart(source, piece, position, orientation) {
                // In play mode: only allow dragging on player's turn
                if (typeof isPlaying !== 'undefined' && isPlaying) {
                    if (!isPlayerTurn) return false;

                    // Only allow player to move their own pieces
                    if (playerColor === 'white' && piece.search(/^b/) !== -1) return false;
                    if (playerColor === 'black' && piece.search(/^w/) !== -1) return false;

                    return true;
                }

                // Coach Demo mode: allow dragging for interactive exploration
                if (typeof gameState !== 'undefined' && gameState.activeMode === 'coachDemo') {
                    // Don't allow moves while waiting for coach response
                    if (gameState.isWaitingForCoach) return false;

                    // Don't allow moves if game is over
                    if (game.game_over()) return false;

                    // Only pick up pieces for the side to move
                    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                        (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                        return false;
                    }

                    return true;
                }

                // My Game mode: only allow dragging at end of history
                if (currentMoveIndex < moveHistory.length - 1) {
                    return false;
                }

                // Don't allow moves if game is over
                if (game.game_over()) return false;

                // Only pick up pieces for the side to move
                if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                    (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                    return false;
                }
            }

            function onDrop(source, target) {
                // Check if in play mode - use global onDropPiece function
                if (typeof isPlaying !== 'undefined' && isPlaying) {
                    return onDropPiece(source, target);
                }

                // Coach Demo mode: allow interactive moves and send to coach
                if (typeof gameState !== 'undefined' && gameState.activeMode === 'coachDemo') {
                    // Capture FEN before the move (needed for evaluation)
                    const fenBefore = game.fen();

                    const move = game.move({
                        from: source,
                        to: target,
                        promotion: 'q'
                    });

                    if (move === null) return 'snapback';

                    // Update board display
                    board.position(game.fen());

                    // Add to move history for navigation
                    moveHistory = moveHistory.slice(0, currentMoveIndex + 1);
                    moveHistory.push({
                        move: move,
                        fen: game.fen()
                    });
                    currentMoveIndex++;
                    updateDisplay();
                    updateButtons();

                    // Send move to coach for feedback
                    handleCoachDemoMove(fenBefore, move.san);
                    return;
                }

                // My Game mode: normal move behavior
                const move = game.move({
                    from: source,
                    to: target,
                    promotion: 'q'
                });

                // Illegal move
                if (move === null) return 'snapback';

                // Add move to history
                moveHistory = moveHistory.slice(0, currentMoveIndex + 1);
                moveHistory.push({
                    move: move,
                    fen: game.fen()
                });
                currentMoveIndex++;

                updateDisplay();
                updateButtons();
            }

            function onSnapEnd() {
                board.position(game.fen());
            }

            // Update the info display
            function updateDisplay() {
                const moveNum = currentMoveIndex >= 0 ? currentMoveIndex + 1 : 0;
                const totalMoves = moveHistory.length;

                document.getElementById('moveNumber').textContent =
                    totalMoves > 0 ? `${moveNum} / ${totalMoves}` : '-';

                if (currentMoveIndex >= 0 && moveHistory[currentMoveIndex]) {
                    const move = moveHistory[currentMoveIndex].move;
                    document.getElementById('moveNotation').textContent = move.san;
                } else {
                    document.getElementById('moveNotation').textContent = '-';
                }

                document.getElementById('fenDisplay').textContent = game.fen();
            }

            // Update button states
            function updateButtons() {
                document.getElementById('startBtn').disabled = currentMoveIndex < 0;
                document.getElementById('prevBtn').disabled = currentMoveIndex < 0;
                document.getElementById('nextBtn').disabled = currentMoveIndex >= moveHistory.length - 1;
                document.getElementById('endBtn').disabled = currentMoveIndex >= moveHistory.length - 1;
            }

            // Show status message
            function showStatus(message, type = 'success') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status-message ${type}`;
                statusEl.style.display = 'block';

                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }

            // Navigation functions
            function goToStart() {
                if (moveHistory.length === 0) return;

                currentMoveIndex = -1;
                game.reset();
                board.position('start');
                updateDisplay();
                updateButtons();
            }

            function previousMove() {
                if (currentMoveIndex < 0) return;

                currentMoveIndex--;

                if (currentMoveIndex < 0) {
                    game.reset();
                    board.position('start');
                } else {
                    game.load(moveHistory[currentMoveIndex].fen);
                    board.position(moveHistory[currentMoveIndex].fen);
                }

                updateDisplay();
                updateButtons();
            }

            function nextMove() {
                if (currentMoveIndex >= moveHistory.length - 1) return;

                currentMoveIndex++;
                game.load(moveHistory[currentMoveIndex].fen);
                board.position(moveHistory[currentMoveIndex].fen);

                updateDisplay();
                updateButtons();
            }

            function goToEnd() {
                if (moveHistory.length === 0) return;

                currentMoveIndex = moveHistory.length - 1;
                game.load(moveHistory[currentMoveIndex].fen);
                board.position(moveHistory[currentMoveIndex].fen);

                updateDisplay();
                updateButtons();
            }

            function flipBoard() {
                board.flip();
            }

            function orient(color) {
                board.orientation(color);
            }

            function resetBoard() {
                game.reset();
                board.start();
                moveHistory = [];
                currentMoveIndex = -1;
                updateDisplay();
                updateButtons();
                showStatus('Board reset to starting position');
            }

            // Public API: Set position from FEN string
            function setPosition(fen) {
                try {
                    const tempGame = new Chess();
                    if (!tempGame.load(fen)) {
                        throw new Error('Invalid FEN');
                    }

                    game.load(fen);
                    board.position(fen);
                    moveHistory = [];
                    currentMoveIndex = -1;
                    updateDisplay();
                    updateButtons();
                    showStatus('Position set successfully');
                    return true;
                } catch (e) {
                    showStatus('Invalid FEN string: ' + e.message, 'error');
                    return false;
                }
            }

            // Public API: Make a move programmatically
            function makeMove(from, to, promotion = 'q') {
                try {
                    const move = game.move({
                        from: from,
                        to: to,
                        promotion: promotion
                    });

                    if (move === null) {
                        throw new Error('Illegal move');
                    }

                    board.position(game.fen());

                    // Add to history
                    moveHistory = moveHistory.slice(0, currentMoveIndex + 1);
                    moveHistory.push({
                        move: move,
                        fen: game.fen()
                    });
                    currentMoveIndex++;

                    updateDisplay();
                    updateButtons();
                    return move;
                } catch (e) {
                    showStatus('Invalid move: ' + e.message, 'error');
                    return null;
                }
            }

            // Public API: Load PGN from string
            function loadPGN(pgnString) {
                try {
                    const tempGame = new Chess();
                    if (!tempGame.load_pgn(pgnString)) {
                        throw new Error('Invalid PGN');
                    }

                    // Reset everything
                    game.reset();
                    moveHistory = [];
                    currentMoveIndex = -1;

                    // Parse the PGN and build move history
                    const moves = tempGame.history({ verbose: true });
                    game.reset();

                    for (let i = 0; i < moves.length; i++) {
                        const move = game.move(moves[i].san);
                        moveHistory.push({
                            move: move,
                            fen: game.fen()
                        });
                    }

                    // Go to start position
                    game.reset();
                    board.start();
                    currentMoveIndex = -1;

                    updateDisplay();
                    updateButtons();
                    showStatus(`PGN loaded successfully (${moveHistory.length} moves)`);
                    return true;
                } catch (e) {
                    showStatus('Failed to load PGN: ' + e.message, 'error');
                    return false;
                }
            }

            // Handle file input
            function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const pgnText = e.target.result;
                    loadPGN(pgnText);
                };
                reader.readAsText(file);

                // Reset the file input so the same file can be loaded again
                event.target.value = '';
            }

            // Get current FEN
            function getCurrentFEN() {
                return game.fen();
            }

            function getPGN() {
                // If there's no move history, return current game state
                if (moveHistory.length === 0) {
                    return game.pgn();
                }

                // Rebuild PGN from move history
                const tempGame = new Chess();
                for (let i = 0; i < moveHistory.length; i++) {
                    tempGame.move(moveHistory[i].move.san);
                }
                return tempGame.pgn();
            }

            function getGameStatus() {
                return {
                    isGameOver: game.game_over(),
                    inCheckmate: game.in_checkmate(),
                    inStalemate: game.in_stalemate(),
                    inThreefoldRepetition: game.in_threefold_repetition(),
                    inDraw: game.in_draw(),
                    insufficientMaterial: game.insufficient_material(),
                    turn: game.turn()
                };
            }

            // Public interface
            return {
                init: init,
                setPosition: setPosition,
                makeMove: makeMove,
                loadPGN: loadPGN,
                goToStart: goToStart,
                previousMove: previousMove,
                nextMove: nextMove,
                goToEnd: goToEnd,
                flipBoard: flipBoard,
                orient: orient,
                resetBoard: resetBoard,
                handleFileSelect: handleFileSelect,
                getCurrentFEN: getCurrentFEN,
                getPGN: getPGN,
                getGameStatus: getGameStatus
            };
        })();

        // Initialize when page loads
        $(document).ready(function() {
            chessBoard.init();

            // Set up file input handler
            document.getElementById('pgnFileInput').addEventListener('change', chessBoard.handleFileSelect);
        });

        // Keyboard shortcuts (skip when typing in chat input)
        document.addEventListener('keydown', function(e) {
            const activeId = document.activeElement && document.activeElement.id;
            if (activeId === 'chatInput' || activeId === 'pgn-batch-input' || activeId === 'batch-username') return;

            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    chessBoard.previousMove();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    chessBoard.nextMove();
                    break;
                case 'Home':
                    e.preventDefault();
                    chessBoard.goToStart();
                    break;
                case 'End':
                    e.preventDefault();
                    chessBoard.goToEnd();
                    break;
            }
        });

        // Position Analysis Functions
        const API_BASE_URL = 'http://localhost:8000';

        async function analyzeCurrentPosition() {
            const analysisPanel = document.getElementById('analysisPanel');
            const analysisContent = document.getElementById('analysisContent');
            const analyzeBtn = document.getElementById('analyzeBtn');

            // Get current FEN
            const fen = chessBoard.getCurrentFEN();

            // Show analysis panel with loading state
            analysisPanel.classList.add('visible');
            analysisContent.innerHTML = '<div class="loading">Analyzing position...</div>';
            analyzeBtn.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fen: fen,
                        depth: 15
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Analysis failed');
                }

                const data = await response.json();
                displayAnalysis(data);

            } catch (error) {
                analysisContent.innerHTML = `
                    <div class="error" style="color: #c62828; text-align: center;">
                        <strong>Error:</strong> ${error.message}
                        <br><small>Make sure the backend server is running on port 8000</small>
                    </div>
                `;
            } finally {
                analyzeBtn.disabled = false;
            }
        }

        function displayAnalysis(data) {
            const analysisContent = document.getElementById('analysisContent');
            const { evaluation, best_move_san } = data;

            // Format evaluation
            let evalText = '';
            let evalClass = 'neutral';

            if (evaluation.type === 'mate') {
                const mateValue = evaluation.value;
                if (mateValue > 0) {
                    evalText = `M${Math.abs(mateValue)}`;
                    evalClass = 'positive';
                } else {
                    evalText = `M-${Math.abs(mateValue)}`;
                    evalClass = 'negative';
                }
            } else {
                // Centipawn evaluation
                const cpValue = evaluation.value;
                if (cpValue > 0) {
                    evalText = `+${cpValue.toFixed(2)}`;
                    evalClass = 'positive';
                } else if (cpValue < 0) {
                    evalText = cpValue.toFixed(2);
                    evalClass = 'negative';
                } else {
                    evalText = '0.00';
                    evalClass = 'neutral';
                }
            }

            // Build HTML
            let html = `
                <div class="evaluation-display ${evalClass}">
                    ${evalText}
                </div>
            `;

            if (best_move_san) {
                html += `
                    <div class="best-move-display">
                        <span class="label">Best move:</span>
                        <span class="move">${best_move_san}</span>
                    </div>
                `;
            }

            html += `
                <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                    Depth: ${data.depth}
                </div>
            `;

            analysisContent.innerHTML = html;
        }

        // Play vs Coach Mode
        let isPlaying = false;
        let playerColor = null;  // 'white' or 'black'
        let isPlayerTurn = false;

        function startGameAsWhite() {
            // Reset game
            chessBoard.resetBoard();
            chessBoard.orient('white');
            isPlaying = true;
            playerColor = 'white';
            isPlayerTurn = true;

            updateGameStatus("Your turn (White)");
            document.getElementById('gameActions').style.display = 'flex';

            // Hide analysis panel
            document.getElementById('analysisPanel').classList.remove('visible');
        }

        function startGameAsBlack() {
            // Reset game
            chessBoard.resetBoard();
            chessBoard.orient('black');
            isPlaying = true;
            playerColor = 'black';
            isPlayerTurn = false;

            updateGameStatus("Coach thinking...");
            document.getElementById('gameActions').style.display = 'flex';

            // Hide analysis panel
            document.getElementById('analysisPanel').classList.remove('visible');

            // Coach (White) makes first move
            setTimeout(() => requestCoachMove(), 500);
        }

        async function requestCoachMove() {
            if (!isPlaying) return;

            const fen = chessBoard.getCurrentFEN();
            const elo = parseInt(document.getElementById('eloSelect').value);

            updateGameStatus("Coach thinking...", "coach-thinking");

            try {
                const response = await fetch(`${API_BASE_URL}/api/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ fen, elo })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Failed to get coach move');
                }

                const data = await response.json();

                // Apply coach's move
                const move = data.move;
                const from = move.substring(0, 2);
                const to = move.substring(2, 4);
                const promotion = move.length > 4 ? move[4] : 'q';

                chessBoard.makeMove(from, to, promotion);

                // Check if game is over
                const gameResult = checkGameOver();
                if (gameResult) {
                    endGame(gameResult);
                } else {
                    isPlayerTurn = true;
                    updateGameStatus(`Your turn (${playerColor === 'white' ? 'White' : 'Black'})`, "your-turn");
                }

            } catch (error) {
                updateGameStatus("Error: " + error.message, "game-over");
                isPlaying = false;
            }
        }

        function onDropPiece(source, target) {
            // Only allow moves when it's player's turn in play mode
            if (isPlaying && !isPlayerTurn) {
                return 'snapback';
            }

            // Try to make the move
            const move = chessBoard.makeMove(source, target);

            if (move === null && isPlaying) {
                return 'snapback';
            }

            if (isPlaying && move !== null) {
                isPlayerTurn = false;

                // Check if game is over
                const gameResult = checkGameOver();
                if (gameResult) {
                    endGame(gameResult);
                } else {
                    // Request coach's move
                    setTimeout(() => requestCoachMove(), 500);
                }
            }
        }

        function checkGameOver() {
            const status = chessBoard.getGameStatus();

            if (status.inCheckmate) {
                const winner = status.turn === 'w' ? 'Black' : 'White';
                return `Checkmate! ${winner} wins!`;
            } else if (status.inStalemate) {
                return 'Draw by stalemate.';
            } else if (status.inThreefoldRepetition) {
                return 'Draw by threefold repetition.';
            } else if (status.insufficientMaterial) {
                return 'Draw by insufficient material.';
            } else if (status.inDraw) {
                return 'Draw!';
            }

            return null;
        }

        function endGame(result) {
            isPlaying = false;
            isPlayerTurn = false;
            updateGameStatus(result, "game-over");
            document.getElementById('gameActions').style.display = 'none';
        }

        function resignGame() {
            if (!isPlaying) return;
            const winner = playerColor === 'white' ? 'Black' : 'White';
            endGame(`${winner} wins by resignation.`);
        }

        function offerDraw() {
            if (!isPlaying) return;
            endGame('Draw by agreement.');
        }

        function updateGameStatus(message, className = "your-turn") {
            const statusDiv = document.getElementById('gameStatus');
            statusDiv.textContent = message;
            statusDiv.className = `game-status visible ${className}`;
        }

        // Game Analysis Functions
        let currentGameAnalysis = null;

        async function analyzeFullGame() {
            // Get PGN from current game
            const pgn = chessBoard.getPGN();
            if (!pgn || pgn.trim() === '') {
                alert('No game loaded. Please load a PGN file or play a game first.');
                return;
            }

            // Estimate move count from PGN (rough estimate)
            const moveMatches = pgn.match(/\d+\./g);
            const estimatedMoves = moveMatches ? moveMatches.length * 2 : 40;
            const estimatedSeconds = estimatedMoves * 2.5; // ~2.5 seconds per move at depth 15
            const estimatedMinutes = Math.ceil(estimatedSeconds / 60);

            // Show loading state
            document.getElementById('analyzeGameBtn').disabled = true;
            document.getElementById('loadingAnalysis').style.display = 'block';
            document.getElementById('analysisResults').classList.remove('visible');

            // Update loading details
            const detailsDiv = document.getElementById('loadingDetails');
            detailsDiv.textContent = `Analyzing ~${estimatedMoves} moves (estimated time: ${estimatedMinutes} ${estimatedMinutes === 1 ? 'minute' : 'minutes'})`;

            // Start progress simulation
            let progress = 0;
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');

            const progressInterval = setInterval(() => {
                if (progress < 90) {
                    // Gradually increase to 90% (leave 10% for final processing)
                    progress += Math.random() * 3;
                    progress = Math.min(progress, 90);
                    progressBar.style.width = progress + '%';
                    progressText.textContent = Math.floor(progress) + '%';
                }
            }, 500);

            try {
                const startTime = Date.now();

                const response = await fetch(`${API_BASE_URL}/api/game/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        pgn: pgn,
                        depth: 15  // Default depth
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Analysis failed');
                }

                const analysisData = await response.json();

                // Complete the progress bar
                clearInterval(progressInterval);
                progressBar.style.width = '100%';
                progressText.textContent = '100%';

                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                detailsDiv.textContent = `Analysis complete! (${elapsedSeconds} seconds, ${analysisData.summary.total_moves} moves analyzed)`;

                // Wait a moment to show completion
                await new Promise(resolve => setTimeout(resolve, 500));

                currentGameAnalysis = analysisData;
                displayGameAnalysis(analysisData);

            } catch (error) {
                clearInterval(progressInterval);
                console.error('Game analysis error:', error);
                alert(`Analysis failed: ${error.message}`);
            } finally {
                document.getElementById('analyzeGameBtn').disabled = false;
                document.getElementById('loadingAnalysis').style.display = 'none';

                // Reset progress bar
                progressBar.style.width = '0%';
                progressText.textContent = '0%';
            }
        }

        function displayGameAnalysis(data) {
            // Show results panel
            document.getElementById('analysisResults').classList.add('visible');

            // Display accuracy
            document.getElementById('whiteAccuracy').textContent = data.summary.white_accuracy.toFixed(1) + '%';
            document.getElementById('blackAccuracy').textContent = data.summary.black_accuracy.toFixed(1) + '%';

            // Display mistake counts
            document.getElementById('whiteMistakes').textContent =
                `Blunders: ${data.summary.white_blunders} | Mistakes: ${data.summary.white_mistakes} | Inaccuracies: ${data.summary.white_inaccuracies}`;
            document.getElementById('blackMistakes').textContent =
                `Blunders: ${data.summary.black_blunders} | Mistakes: ${data.summary.black_mistakes} | Inaccuracies: ${data.summary.black_inaccuracies}`;

            // Build moves list
            const movesList = document.getElementById('movesList');
            movesList.innerHTML = '';

            data.moves.forEach((move, index) => {
                const moveItem = document.createElement('div');
                moveItem.className = `move-item ${move.classification}`;

                const moveText = move.color === 'white'
                    ? `${move.move_number}. ${move.move_san}`
                    : `${move.move_number}... ${move.move_san}`;

                const evalText = move.eval_after !== null
                    ? ` (${move.eval_after > 0 ? '+' : ''}${move.eval_after.toFixed(2)})`
                    : '';

                moveItem.textContent = `${moveText}${evalText} - ${move.classification}`;

                // Make clickable to jump to position
                moveItem.onclick = () => {
                    chessBoard.setPosition(move.fen_after);
                };

                // Add tooltip with best move for non-excellent moves
                if (move.classification !== 'excellent' && move.classification !== 'good') {
                    moveItem.title = `Best: ${move.best_move_san} (eval change: ${move.eval_change.toFixed(2)})`;
                }

                movesList.appendChild(moveItem);
            });
        }

        function exportPlainPGN() {
            const pgn = chessBoard.getPGN();
            if (!pgn || pgn.trim() === '') {
                alert('No game to export. Please load a PGN file or play a game first.');
                return;
            }

            const filename = `game_${new Date().toISOString().slice(0, 10)}.pgn`;
            downloadPGN(pgn, filename);
        }

        function exportAnnotatedPGN() {
            if (!currentGameAnalysis || !currentGameAnalysis.moves) {
                alert('Please analyze the game first before exporting annotated PGN.');
                return;
            }

            const pgn = generateAnnotatedPGN(currentGameAnalysis.moves);
            const filename = `game_annotated_${new Date().toISOString().slice(0, 10)}.pgn`;
            downloadPGN(pgn, filename);
        }

        function generateAnnotatedPGN(moves) {
            let pgn = '';
            let moveNumber = 1;

            for (let i = 0; i < moves.length; i++) {
                const move = moves[i];

                // Add move number for white's move
                if (move.color === 'white') {
                    pgn += `${moveNumber}. `;
                }

                // Add the move
                pgn += move.move_san;

                // Add annotation based on classification
                if (move.classification === 'blunder') {
                    pgn += '??';
                } else if (move.classification === 'mistake') {
                    pgn += '?';
                } else if (move.classification === 'inaccuracy') {
                    pgn += '?!';
                } else if (move.classification === 'excellent') {
                    pgn += '!';
                }

                // Add evaluation and best move comment for non-good moves
                if (['blunder', 'mistake', 'inaccuracy'].includes(move.classification)) {
                    const evalBefore = move.eval_before !== null ? move.eval_before.toFixed(2) : '?';
                    const evalAfter = move.eval_after !== null ? move.eval_after.toFixed(2) : '?';
                    pgn += ` {${move.classification}. ${evalBefore} â†’ ${evalAfter}. Best: ${move.best_move_san}}`;
                } else {
                    const evalAfter = move.eval_after !== null ? move.eval_after.toFixed(2) : '?';
                    pgn += ` {${evalAfter > 0 ? '+' : ''}${evalAfter}}`;
                }

                pgn += ' ';

                // Increment move number after black's move
                if (move.color === 'black') {
                    moveNumber++;
                }
            }

            return pgn.trim();
        }

        function downloadPGN(content, filename) {
            const blob = new Blob([content], { type: 'application/x-chess-pgn' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ===== Tab Switching =====
        function switchTab(tabName) {
            // Toggle content
            document.getElementById('toolsTab').style.display = tabName === 'tools' ? '' : 'none';
            document.getElementById('batchTab').style.display = tabName === 'batch' ? '' : 'none';

            // Toggle active button
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });
        }

        // ===== Batch Analysis =====
        const batchAnalysis = {
            games: [],
            analyzedGames: [],
            patternSummary: null,
            timestamp: null,
            username: null
        };

        function loadBatchFromStorage() {
            const stored = localStorage.getItem('chess_batch_analysis');
            if (!stored) return;
            try {
                const data = JSON.parse(stored);
                Object.assign(batchAnalysis, data);
                if (batchAnalysis.username) {
                    document.getElementById('batch-username').value = batchAnalysis.username;
                }
                if (batchAnalysis.patternSummary) {
                    displayPatternSummary(batchAnalysis.patternSummary);
                }
            } catch (e) {
                console.error('Failed to load stored batch analysis:', e);
            }
        }

        function saveBatchToStorage() {
            localStorage.setItem('chess_batch_analysis', JSON.stringify(batchAnalysis));
        }

        function splitPGNs(text) {
            // Split on [Event headers â€” each game starts with [Event
            const parts = text.split(/(?=\[Event\s)/);
            return parts.map(p => p.trim()).filter(p => p.length > 0);
        }

        async function analyzeBatchGames() {
            const textarea = document.getElementById('pgn-batch-input');
            const pgnText = textarea.value.trim();

            if (!pgnText) {
                showBatchStatus('error', 'Please paste some games first.');
                return;
            }

            const pgns = splitPGNs(pgnText);

            if (pgns.length < 5) {
                showBatchStatus('error', `Please provide at least 5 games (found ${pgns.length}).`);
                return;
            }

            const username = document.getElementById('batch-username').value.trim();

            showBatchStatus('loading', `Analyzing ${pgns.length} games... This may take a few minutes.`);
            document.getElementById('analyze-batch-btn').disabled = true;

            try {
                const payload = { pgns };
                if (username) {
                    payload.username = username;
                }

                const response = await fetch(`${API_BASE_URL}/api/games/analyze-batch`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Analysis failed');
                }

                const data = await response.json();

                // Update state
                batchAnalysis.games = pgns;
                batchAnalysis.analyzedGames = data.analyzed_games;
                batchAnalysis.patternSummary = data.pattern_summary;
                batchAnalysis.timestamp = new Date().toISOString();
                batchAnalysis.username = username || null;

                saveBatchToStorage();
                displayPatternSummary(data.pattern_summary);
                showBatchStatus('success', `Successfully analyzed ${pgns.length} games!`);

            } catch (error) {
                showBatchStatus('error', `Error: ${error.message}`);
                console.error('Batch analysis error:', error);
            } finally {
                document.getElementById('analyze-batch-btn').disabled = false;
            }
        }

        function showBatchStatus(type, message) {
            const el = document.getElementById('batch-status');
            el.className = `batch-status ${type}`;
            el.textContent = message;
        }

        function displayPatternSummary(summary) {
            document.getElementById('pattern-summary').style.display = 'block';

            document.getElementById('total-games').textContent = summary.total_games;
            document.getElementById('overall-accuracy').textContent =
                summary.overall_accuracy.toFixed(1) + '%';

            // Recommendations
            const recList = document.getElementById('recommendations-list');
            recList.innerHTML = summary.recommendations
                .map(rec => `<li>${rec}</li>`)
                .join('');

            // Tactical patterns
            displayTacticalPatterns(summary.tactical_patterns);

            // Phase stats
            displayPhaseStats(summary.phase_stats);
        }

        function displayTacticalPatterns(patterns) {
            const container = document.getElementById('tactical-patterns');

            const entries = Object.entries(patterns).filter(([_, inst]) => inst.length > 0);

            if (entries.length === 0) {
                container.innerHTML = '<p style="color: #666;">No significant tactical patterns detected.</p>';
                return;
            }

            container.innerHTML = entries
                .map(([patternType, instances]) => {
                    const name = patternType.replace(/_/g, ' ').toUpperCase();
                    const shown = instances.slice(0, 3);
                    const instancesHtml = shown
                        .map(inst => `
                            <div class="pattern-instance">
                                Game ${inst.game_index + 1}, Move ${inst.move_number}:
                                ${inst.description}
                                (Lost ${inst.lost_material} pawns)
                            </div>
                        `).join('');
                    const more = instances.length > 3
                        ? `<div class="pattern-instance">...and ${instances.length - 3} more</div>`
                        : '';
                    return `
                        <div class="pattern-item">
                            <h6>${name} (${instances.length} instance${instances.length !== 1 ? 's' : ''})</h6>
                            ${instancesHtml}${more}
                        </div>
                    `;
                }).join('');
        }

        function displayPhaseStats(phaseStats) {
            const container = document.getElementById('phase-stats');

            const entries = Object.entries(phaseStats);
            if (entries.length === 0) {
                container.innerHTML = '<p style="color: #666;">No phase data available.</p>';
                return;
            }

            container.innerHTML = entries
                .map(([phase, stats]) => `
                    <div class="phase-stat">
                        <span class="phase-name">${phase}</span>
                        <div>
                            <span class="phase-accuracy">${stats.avg_accuracy.toFixed(1)}%</span>
                            <span class="phase-errors">
                                ${stats.blunder_count} blunders, ${stats.mistake_count} mistakes
                            </span>
                        </div>
                    </div>
                `).join('');
        }

        // Export / Import
        function exportBatchAnalysis() {
            if (!batchAnalysis.patternSummary) {
                alert('No analysis to export. Analyze some games first.');
                return;
            }

            const data = JSON.stringify(batchAnalysis, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chess_analysis_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importBatchAnalysis(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.patternSummary || !data.analyzedGames) {
                        throw new Error('Invalid analysis file format');
                    }
                    Object.assign(batchAnalysis, data);
                    saveBatchToStorage();
                    displayPatternSummary(data.patternSummary);
                    showBatchStatus('success', `Loaded analysis of ${data.patternSummary.total_games} games`);
                    switchTab('batch');
                } catch (error) {
                    alert(`Failed to import: ${error.message}`);
                }
            };
            reader.readAsText(file);
            document.getElementById('import-file').value = '';
        }

        // Wire up batch analysis event handlers
        $(document).ready(function() {
            document.getElementById('analyze-batch-btn').addEventListener('click', analyzeBatchGames);

            document.getElementById('clear-batch-btn').addEventListener('click', () => {
                document.getElementById('pgn-batch-input').value = '';
                document.getElementById('pattern-summary').style.display = 'none';
                document.getElementById('batch-status').className = 'batch-status';
                batchAnalysis.games = [];
                batchAnalysis.analyzedGames = [];
                batchAnalysis.patternSummary = null;
                batchAnalysis.timestamp = null;
                saveBatchToStorage();
            });

            document.getElementById('export-analysis-btn').addEventListener('click', exportBatchAnalysis);

            document.getElementById('import-analysis-btn').addEventListener('click', () => {
                document.getElementById('import-file').click();
            });

            document.getElementById('import-file').addEventListener('change', (e) => {
                importBatchAnalysis(e.target.files[0]);
            });

            // Load persisted batch analysis
            loadBatchFromStorage();
        });

        // ===== Chat Functions =====
        let conversationHistory = [];
        let currentLessonPlan = null;

        function initChat() {
            addChatMessage('assistant', "Hi! I'm your chess coach. What would you like to work on today?");
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSendBtn');
            const message = input.value.trim();

            if (!message) return;

            // Clear input and disable send
            input.value = '';
            sendBtn.disabled = true;

            // Display user message
            addChatMessage('user', message);

            // Show thinking indicator
            const thinkingId = addChatMessage('assistant', 'Thinking...', true);

            // Gather board context
            const boardContext = {
                fen: chessBoard.getCurrentFEN(),
                last_move: document.getElementById('moveNotation').textContent !== '-'
                    ? document.getElementById('moveNotation').textContent
                    : null,
                mode: getCurrentMode()
            };

            try {
                // Include pattern context if batch analysis is available
                const chatPayload = {
                    message: message,
                    conversation_history: conversationHistory,
                    board_context: boardContext
                };
                if (batchAnalysis.patternSummary) {
                    chatPayload.pattern_context = batchAnalysis.patternSummary;
                }

                const response = await fetch(`${API_BASE_URL}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(chatPayload)
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Failed to get response');
                }

                const data = await response.json();

                // Remove thinking indicator, show real response
                removeChatMessage(thinkingId);
                addChatMessage('assistant', data.message);

                // Handle board control if Claude demonstrated a position
                if (data.board_control) {
                    switchToCoachDemo(data.board_control);
                }

                // Handle lesson plan if present
                if (data.suggested_action && data.suggested_action.type === 'start_lesson') {
                    currentLessonPlan = data.suggested_action.lesson_plan;
                    displayLessonPlan(currentLessonPlan);
                }

                // Update conversation history
                conversationHistory.push({ role: 'user', content: message });
                conversationHistory.push({ role: 'assistant', content: data.message });

            } catch (error) {
                removeChatMessage(thinkingId);
                addChatMessage('assistant', 'Sorry, I had trouble responding. Please try again.');
                console.error('Chat error:', error);
            } finally {
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function addChatMessage(role, content, isThinking = false) {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            const messageId = 'msg-' + Date.now();

            messageDiv.id = messageId;
            messageDiv.className = `chat-message ${role}${isThinking ? ' thinking' : ''}`;
            messageDiv.textContent = content;

            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            return messageId;
        }

        function removeChatMessage(messageId) {
            const el = document.getElementById(messageId);
            if (el) el.remove();
        }

        function handleChatKeypress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        function getCurrentMode() {
            if (gameState.activeMode === 'coachDemo') return 'coachDemo';
            if (currentLessonPlan) return 'lesson';
            if (typeof isPlaying !== 'undefined' && isPlaying) return 'play';
            const analysisPanel = document.getElementById('analysisPanel');
            if (analysisPanel && analysisPanel.classList.contains('visible')) return 'analysis';
            return 'idle';
        }

        function displayLessonPlan(plan) {
            const messagesDiv = document.getElementById('chatMessages');
            const card = document.createElement('div');
            card.className = 'lesson-plan-card';

            const goalsHtml = plan.goals
                ? plan.goals.map(g => `<li>${g}</li>`).join('')
                : '';

            let sourceHtml = '';
            if (plan.source_reference) {
                const ref = plan.source_reference;
                const parts = [ref.book, ref.chapter, ref.section].filter(Boolean);
                if (parts.length) {
                    sourceHtml = `<div class="lesson-source">Source: ${parts.join(' > ')}</div>`;
                }
            }

            card.innerHTML = `
                <h4>Lesson: ${plan.topic || 'Practice Session'}</h4>
                <span class="lesson-type">${(plan.type || plan.activity?.type || '').replace(/_/g, ' ')}</span>
                ${goalsHtml ? `<ul>${goalsHtml}</ul>` : ''}
                ${sourceHtml}
            `;

            messagesDiv.appendChild(card);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Show lesson banner
            const banner = document.getElementById('lessonBanner');
            banner.textContent = 'Lesson active: ' + (plan.topic || 'Practice Session');
            banner.classList.add('visible');
        }

        // Initialize chat on page load
        $(document).ready(function() {
            initChat();
        });

        // ===== Board Control: Game State Management (Tasks 6-10) =====

        const gameState = {
            // My Game mode state
            myGame: {
                pgn: "",
                currentMove: -1,
                fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
            },
            // Coach Demo mode state
            coachDemo: {
                pgn: "",
                currentMove: -1,
                positions: [],   // [{fen, annotation}, ...]
                fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                isInteractive: true
            },
            // Active mode
            activeMode: "myGame",  // "myGame" or "coachDemo"
            isWaitingForCoach: false
        };

        /**
         * Build a PGN string with a custom starting position via FEN header.
         * chess.js loads this and starts from the given position.
         */
        function buildPGNFromFEN(fen) {
            return [
                '[Event "Coach Demonstration"]',
                '[Site "AI Chess Coach"]',
                '[FEN "' + fen + '"]',
                '[SetUp "1"]',
                '',
                '*'
            ].join('\n');
        }

        /**
         * Switch to Coach Demo mode with board control data from Claude.
         * Called automatically when Claude uses the set_board_position tool.
         */
        function switchToCoachDemo(boardControl) {
            // Save current My Game state if we're switching from it
            if (gameState.activeMode === "myGame") {
                gameState.myGame.pgn = chessBoard.getPGN();
                gameState.myGame.fen = chessBoard.getCurrentFEN();
                // Save current move index via the display (we don't have direct access)
                const moveNumText = document.getElementById('moveNumber').textContent;
                const match = moveNumText.match(/^(\d+)/);
                gameState.myGame.currentMove = match ? parseInt(match[1]) - 1 : -1;
            }

            // Set up Coach Demo state
            gameState.coachDemo.fen = boardControl.fen;
            gameState.coachDemo.positions.push({
                fen: boardControl.fen,
                annotation: boardControl.annotation
            });

            // Switch mode
            gameState.activeMode = "coachDemo";

            // Update UI toggle buttons
            document.getElementById('myGameMode').classList.remove('active');
            document.getElementById('coachDemoMode').classList.add('active');
            document.getElementById('coachDemoMode').disabled = false;

            // Load the position on the board
            chessBoard.setPosition(boardControl.fen);

            // Orient board to the appropriate perspective
            chessBoard.orient(boardControl.orientation || 'white');

            // Show annotation
            showAnnotation(boardControl.annotation);
        }

        /**
         * Manual switch to Coach Demo (clicking the button).
         * Only available if there are coach positions to show.
         */
        function switchToCoachDemoManual() {
            if (gameState.coachDemo.positions.length === 0) return;

            // Save My Game state
            if (gameState.activeMode === "myGame") {
                gameState.myGame.pgn = chessBoard.getPGN();
                gameState.myGame.fen = chessBoard.getCurrentFEN();
                const moveNumText = document.getElementById('moveNumber').textContent;
                const match = moveNumText.match(/^(\d+)/);
                gameState.myGame.currentMove = match ? parseInt(match[1]) - 1 : -1;
            }

            gameState.activeMode = "coachDemo";

            // Update toggle buttons
            document.getElementById('myGameMode').classList.remove('active');
            document.getElementById('coachDemoMode').classList.add('active');

            // Restore last coach demo position
            const lastPos = gameState.coachDemo.positions[gameState.coachDemo.positions.length - 1];
            chessBoard.setPosition(lastPos.fen);
            showAnnotation(lastPos.annotation);
        }

        /**
         * Switch back to My Game mode. Restores the user's game state.
         */
        function switchToMyGame() {
            if (gameState.activeMode === "myGame") return;

            gameState.activeMode = "myGame";

            // Update toggle buttons
            document.getElementById('coachDemoMode').classList.remove('active');
            document.getElementById('myGameMode').classList.add('active');

            // Hide annotation
            hideAnnotation();

            // Restore My Game state
            if (gameState.myGame.pgn) {
                chessBoard.loadPGN(gameState.myGame.pgn);
                // Navigate to the saved move
                if (gameState.myGame.currentMove >= 0) {
                    chessBoard.goToStart();
                    for (let i = 0; i <= gameState.myGame.currentMove; i++) {
                        chessBoard.nextMove();
                    }
                }
            } else {
                chessBoard.setPosition(gameState.myGame.fen);
            }
        }

        function showAnnotation(text) {
            const panel = document.getElementById('annotationPanel');
            panel.textContent = text;
            panel.classList.add('visible');
        }

        function hideAnnotation() {
            const panel = document.getElementById('annotationPanel');
            panel.classList.remove('visible');
        }

        /**
         * Show "Coach is analyzing..." indicator in chat.
         */
        function showCoachThinking() {
            const messagesDiv = document.getElementById('chatMessages');
            const indicator = document.createElement('div');
            indicator.id = 'coach-thinking';
            indicator.className = 'coach-thinking-indicator';
            indicator.textContent = 'Coach is analyzing your move...';
            messagesDiv.appendChild(indicator);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function hideCoachThinking() {
            const el = document.getElementById('coach-thinking');
            if (el) el.remove();
        }

        /**
         * Handle a user move in Coach Demo mode.
         * Sends FEN (before move) + move SAN to the backend for coaching.
         */
        async function handleCoachDemoMove(fenBefore, moveSan) {
            gameState.isWaitingForCoach = true;
            showCoachThinking();

            try {
                const response = await fetch(API_BASE_URL + '/api/coach/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fen: fenBefore,
                        move: moveSan,
                        context: {
                            conversation_history: conversationHistory,
                            current_demonstration: gameState.coachDemo.positions.length > 0
                                ? gameState.coachDemo.positions[gameState.coachDemo.positions.length - 1].annotation
                                : 'General coaching'
                        }
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Failed to get coaching response');
                }

                const data = await response.json();

                hideCoachThinking();

                // Add coach response to chat
                addChatMessage('assistant', data.message);

                // Update conversation history
                conversationHistory.push({ role: 'user', content: 'I played: ' + moveSan });
                conversationHistory.push({ role: 'assistant', content: data.message });

                // If coach demonstrates a new position, update the board
                if (data.board_control) {
                    switchToCoachDemo(data.board_control);
                }

            } catch (error) {
                hideCoachThinking();
                console.error('Coach move error:', error);
                addChatMessage('assistant', 'Sorry, I had trouble analyzing that move. Please try again.');
            } finally {
                gameState.isWaitingForCoach = false;
            }
        }
    </script>
</body>
</html>
